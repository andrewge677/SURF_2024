#!/usr/bin/env python

# was called andrews_listener.py

# may be faster than API requests but may not be as accurate

import speech_recognition as sr

import sounddevice as sd
import numpy as np
import scipy.io.wavfile as wav
import threading
import os
import rospy
from std_msgs.msg import String
from intera_interface import Lights

# Set the sample rate
fs = 44100  # Sample rate
stop_recording = None
recording_thread = None
speak_finished = False
action_finished = False
robot_is_free = True
SECONDS_OF_SLEEP = 5.0
TRANSCRIPTION_PATH = '/home/student/ros_ws/src/custom_scripts/transcripts/transcription.txt'
lights = None
LIGHT_NAME = 'head_red_light'

def shutdown_hook():
    """
    Attempts to shut down child threads on interrupt
    """
    global stop_recording, recording_thread
    if not recording_thread is None:
        print("Killing child process.")
        stop_recording.set()
        recording_thread.join()
    print("Exiting recording program.")

def listen_and_transcribe(transcription_node):
    """
    Uses speech_recognition package to transcribe speech.
    While robot is not free, will wait and periodically check to see if robot has become free.
    After listening for 10 cycles or upon receiving the verbal instruction 'quit', will quit program.
    """
    global stop_recording, recording_thread, robot_is_free, lights
    try:
        def record_audio():
            while not stop_recording.is_set():
                # Record audio for 1 second
                myrecording = sd.rec(int(1 * fs), samplerate=fs, channels=2, dtype='int16')
                sd.wait()  # Wait for the recording to finish

                # Append the recording to our list of recordings
                recording.append(myrecording)

            # Concatenate all the recordings into one array
            recording_concat = np.concatenate(recording, axis=0)

            # Save as a WAV file
            # wav.write('../sound_files/output.wav', fs, recording_concat)                      # uncomment if you need wav files for google speech to text api

        # Create a recognizer instance
        r = sr.Recognizer()
        # Create a microphone instance
        mic = sr.Microphone()

        num_failures = 0
        rate = rospy.Rate(1.0/SECONDS_OF_SLEEP)  # Adjust the rate as needed (0.1 Hz means it will run every 10 seconds)

        while num_failures < 10:
            if robot_is_free:
                lights.set_light_state(LIGHT_NAME, on=False)
                with mic as source:

                    # start recording
                    recording = []
                    stop_recording = threading.Event()
                    recording_thread = threading.Thread(target=record_audio)
                    recording_thread.start()

                    rospy.loginfo("speech_to_text_base.py Listening...")
                    audio = r.listen(source)

                    # Try to recognize the speech
                    try:
                        speech = r.recognize_google(audio)                          # speech generated by recognize_google not as robust as Google API call, not used here
                        
                        if(speech == "quit"):
                            rospy.loginfo("speech_to_text_base.py Phrase 'quit' detected, quitting")
                            break
                        
                        rospy.loginfo("speech_to_text_base.py Speech detected: {}".format(speech))    
                        # signal thread to save and end
                        stop_recording.set()      

                        transcription_node.publish(speech) 
                        with open(TRANSCRIPTION_PATH, 'w') as f:
                            f.write(speech)
                            os.chmod(TRANSCRIPTION_PATH, 0o600)  # Owner read/write (rw-------)
                        robot_is_free = False 

                        num_failures = 0       

                    except sr.UnknownValueError:
                        rospy.loginfo("speech_to_text_base.py did not detect input...")
                        # signal thread to save and end
                        stop_recording.set()
                        # delete recording because no speech detected if exists
                        if os.path.exists("recordings/output.wav"):
                            os.remove("recordings/output.wav")
                        num_failures += 1

                    except sr.RequestError:
                        rospy.loginfo("speech_to_text_base.py Issue reaching google speech recognition service")
                    
                    # wait for thread to end
                    recording_thread.join()
                    lights.set_light_state(LIGHT_NAME, on=True)
            else:
                rospy.loginfo("speech_to_text_base.py waiting for robot to complete step")
                num_failures += 1
                if(num_failures > 100):
                    break
                rate.sleep()
        shutdown_hook()

    except KeyboardInterrupt:        
        rospy.loginfo("speech_to_text_base.py keyboard interruption detected, quitting")                 
    except rospy.ROSInterruptException:    
        rospy.loginfo("speech_to_text_base.py ROS interruption detected, quitting")   
    finally:
        shutdown_hook()


def robot_is_free(data):
    """
    Upon finishing a transcription, marks robot as busy in robot_is_free flag.
    When see publish to /robot_finished_step, marks robot as free, 
    and allows new transcriptions to be performed.
    """
    global speak_finished
    global action_finished
    global robot_is_free

    if(data.data == "speak_finished"):
        speak_finished = True
    if(data.data == "action_finished"):
        action_finished = True
    if(speak_finished and action_finished):
        robot_is_free = True
        speak_finished = False
        action_finished = False

def main():
    global transcription_node
    global lights
    rospy.init_node('speech_to_text_base', anonymous=True)
    rospy.loginfo("speech_to_text_base.py entered")
    lights = Lights()
    transcription_node = rospy.Publisher('/transcription', String, queue_size=10)
    rospy.Subscriber('/speak_finished', String, robot_is_free)
    rospy.Subscriber('/action_finished', String, robot_is_free)
    rospy.on_shutdown(shutdown_hook)
    listen_and_transcribe(transcription_node)
    rospy.loginfo("speech_to_text_base.py exiting")

if __name__ == '__main__':
    main()